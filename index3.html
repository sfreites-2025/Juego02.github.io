<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pac-Man Laberinto Avanzado</title>
<style>
  body {
    margin: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #000;
    color: #fff;
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100vh;
    user-select: none;
  }
  h1 {
    margin: 20px 0;
    text-shadow: 0 0 5px #0ff;
  }
  #maze {
    display: grid;
    grid-template-columns: repeat(19, 30px);
    grid-template-rows: repeat(21, 30px);
    gap: 2px;
    background-color: #222;
    border: 3px solid #0ff;
    box-shadow: 0 0 12px #0ffaaaff;
    position: relative;
  }
  .cell {
    width: 30px;
    height: 30px;
    box-sizing: border-box;
  }
  .wall {
    background-color: #00008b;
    box-shadow: inset 0 0 5px #0000ff;
  }
  .path {
    background-color: #111;
    position: relative;
  }
  .player {
    background-color: #ffeb3b;
    border-radius: 50%;
    box-shadow: 0 0 15px 3px #ffeb3b, inset 0 0 10px 3px #fff176;
    position: relative;
    z-index: 10;
  }
  .ghost {
    border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
    position: relative;
    z-index: 5;
  }
  .ghost.blinky {
    background-color: #f00;
    box-shadow: 0 0 15px 3px #f00, inset 0 0 10px 3px #ff5252;
  }
  .ghost.pinky {
    background-color: #ff69b4;
    box-shadow: 0 0 15px 3px #ff69b4, inset 0 0 10px 3px #ff85c1;
  }
  .ghost.inky {
    background-color: #00ffff;
    box-shadow: 0 0 15px 3px #00ffff, inset 0 0 10px 3px #66f0f0;
  }
  .ghost.clyde {
    background-color: #ffa500;
    box-shadow: 0 0 15px 3px #ffa500, inset 0 0 10px 3px #ffcf6a;
  }
  .goal {
    background-color: #4caf50;
    border-radius: 50%;
    box-shadow: 0 0 20px 4px #4caf5011, inset 0 0 10px 3px #81c784;
    position: relative;
    z-index: 1;
  }
  .pill {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 12px;
    height: 12px;
    background-color: #fff59d;
    border-radius: 50%;
    box-shadow: 0 0 8px 1.5px #fff59d;
    transform: translate(-50%, -50%);
    z-index: 1;
  }
  #info {
    margin: 15px;
    font-size: 18px;
    text-shadow: 0 0 5px #0ff;
  }
</style>
</head>
<body>

<h1>Pac-Man Laberinto Avanzado</h1>
<div id="maze"></div>
<div id="info">
  Movimientos: <span id="moves">0</span> |
  Pastillas: <span id="pills">0</span>/7
</div>

<script>
  const mazeElement = document.getElementById('maze');
  const movesCounter = document.getElementById('moves');
  const pillsCounter = document.getElementById('pills');

  const mazeMap = [
    [1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1],
    [1,2,0,0,1,0,0,0,1,4,1,0,0,0,1,0,0,3,1],
    [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
    [0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0],
    [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],
    [1,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,7,1],
    [1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1],
    [1,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,1],
    [1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,1],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1],
    [1,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,1],
    [0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,0],
    [1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1],
    [1,1,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,1,1],
    [1,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,0,0,1,1,1,1,1,1,1,0,1,1,1,0,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1],
  ];

  const rows = mazeMap.length;
  const cols = mazeMap[0].length;

  let playerPosition = { x:0, y:0 };
  let moves = 0;
  let pillsCollected = 0;

  // Declaramos fantasmas con sus IDs desde el mapa (valores 5-8)
  let ghosts = [
    {x:0, y:0, dx:0, dy:0, type: 'blinky'}, // rojo
    {x:0, y:0, dx:0, dy:0, type: 'pinky'},  // rosa
    {x:0, y:0, dx:0, dy:0, type: 'inky'},   // azul
    {x:0, y:0, dx:0, dy:0, type: 'clyde'}   // naranja
  ];

  // Distintas posiciones iniciales para el jugador cuando muere
  const playerStartPositions = [];

  // Guardamos posición inicial fantasmas y jugador según mapa
  function scanPositions(){
    playerStartPositions.length = 0;
    ghosts.forEach(g=>{ g.x=0; g.y=0; g.dx=0; g.dy=0; })
    for(let y=0; y<rows; y++){
      for(let x=0; x<cols; x++){
        const cell = mazeMap[y][x];
        if(cell === 2) {
          playerPosition = {x, y};
          playerStartPositions.push({x,y});
          mazeMap[y][x] = 0;
        }
        if(cell >= 5 && cell <= 8) {
          const index = cell - 5;
          ghosts[index].x = x;
          ghosts[index].y = y;
          ghosts[index].dx = 0;
          ghosts[index].dy = 0;
          mazeMap[y][x] = 0;
        }
        if(cell === 4){
          pillsAvailable.push({x,y});
        }
      }
    }
  }

  let pillsAvailable = [];
  let pillsOnMap = new Set();

  function createMaze() {
    mazeElement.style.gridTemplateColumns = `repeat(${cols}, 30px)`;
    mazeElement.style.gridTemplateRows = `repeat(${rows}, 30px)`;
    mazeElement.innerHTML = '';

    for (let y=0; y<rows; y++) {
      for (let x=0; x<cols; x++) {
        const cellDiv = document.createElement('div');
        cellDiv.classList.add('cell');

        if(mazeMap[y][x] === 1){
          cellDiv.classList.add('wall');
        } else {
          cellDiv.classList.add('path');
          // Si hay pastilla, agregar pastilla visual
          if(isPillAt(x,y)){
            const pillEl = document.createElement('div');
            pillEl.classList.add('pill');
            cellDiv.appendChild(pillEl);
          }
        }
        cellDiv.id = `cell-${x}-${y}`;
        mazeElement.appendChild(cellDiv);
      }
    }
    drawPlayer();
    drawGhosts();
    updatePillsCounter();
  }

  // Ver si hay pastilla en esa posición
  function isPillAt(x,y){
    return pillsOnMap.has(`${x},${y}`);
  }

  function drawPlayer(){
    document.querySelectorAll('.player').forEach(el => el.classList.remove('player'));
    const cell = document.getElementById(`cell-${playerPosition.x}-${playerPosition.y}`);
    if(cell) cell.classList.add('player');
  }

  function drawGhosts(){
    document.querySelectorAll('.ghost').forEach(el => el.classList.remove('ghost', 'blinky', 'pinky', 'inky', 'clyde'));
    ghosts.forEach((g,i) => {
      const cell = document.getElementById(`cell-${g.x}-${g.y}`);
      if(cell){
        cell.classList.add('ghost', g.type);
      }
    });
  }

  function updatePillsCounter(){
    pillsCounter.textContent = pillsCollected;
  }

  // Movimiento jugador con wrap-around
  function movePlayer(dx, dy){
    const newX = (playerPosition.x + dx + cols) % cols;
    const newY = (playerPosition.y + dy + rows) % rows;

    if (mazeMap[newY][newX] === 1) return;

    playerPosition.x = newX;
    playerPosition.y = newY;

    checkPillCollection(newX, newY);
    
    moves++;
    movesCounter.textContent = moves;

    drawPlayer();
    checkGhostCollision();
    checkGoal();
  }

  // Colección de pastillas con reaparecer aleatorio
  function checkPillCollection(x,y){
    const key = `${x},${y}`;
    if(pillsOnMap.has(key)){
      pillsOnMap.delete(key);
      pillsCollected++;
      updatePillsCounter();
      removePillVisual(x,y);
      spawnRandomPill();
    }
  }

  function removePillVisual(x,y){
    const cell = document.getElementById(`cell-${x}-${y}`);
    if(cell){
      const pill = cell.querySelector('.pill');
      if(pill) cell.removeChild(pill);
    }
  }

  // Spawnear pastilla aleatoria en casilla camino vacía sin player ni fantasmas ni pastilla
  function spawnRandomPill(){
    const emptySpaces = [];
    for(let y=0; y<rows; y++){
      for(let x=0; x<cols; x++){
        if(mazeMap[y][x] === 0 && !pillsOnMap.has(`${x},${y}`) && !(playerPosition.x === x && playerPosition.y === y)
          && !ghosts.some(g => g.x===x && g.y===y)
        ){
          emptySpaces.push({x,y});
        }
      }
    }
    if(emptySpaces.length){
      const index = Math.floor(Math.random()*emptySpaces.length);
      const pos = emptySpaces[index];
      pillsOnMap.add(`${pos.x},${pos.y}`);

      // Visual
      const cell = document.getElementById(`cell-${pos.x}-${pos.y}`);
      if(cell){
        const pillEl = document.createElement('div');
        pillEl.classList.add('pill');
        cell.appendChild(pillEl);
      }
    }
  }

  // Reiniciar jugador a posición aleatoria en caminos abiertos
  function resetPlayerPosition(){
    const openSpaces = [];
    for(let y=0; y<rows; y++){
      for(let x=0; x<cols; x++){
        if(mazeMap[y][x] === 0){
          openSpaces.push({x,y});
        }
      }
    }
    if(openSpaces.length){
      const pos = openSpaces[Math.floor(Math.random()*openSpaces.length)];
      playerPosition.x = pos.x;
      playerPosition.y = pos.y;
      drawPlayer();
    }
  }

  // Mover fantasmas con patrones de comportamiento diferentes
  function moveGhosts(){
    ghosts.forEach(g => {
      let target = {x: playerPosition.x, y: playerPosition.y};
      switch(g.type){
        case 'blinky': 
          // Persigue directamente la posición del jugador
          target = {...playerPosition};
          break;
        case 'pinky': 
          // Predice posición 4 pasos hacia adelante según última dirección del jugador
          target = predictPosition(4);
          break;
        case 'inky':
          // Usa posición relativa de blinky y jugador para cálculo vectorial
          const blinky = ghosts.find(f => f.type === 'blinky');
          if (blinky) {
            target = inkyTarget(blinky, playerPosition);
          }
          break;
        case 'clyde':
          // Cambia comportamiento según distancia a jugador
          target = clydeTarget(g, playerPosition);
          break;
      }
      chooseGhostMove(g, target);
    });
    drawGhosts();
  }

  // Predecir posición delante del jugador según último movimiento, aquí asumimos 0 porque sólo movemos con teclas actuales, mejor si se guarda dirección
  // En este ejemplo se usará una predicción simple: 4 celdas derecha, si no posible, igual posición jugador
  function predictPosition(steps){
    // Opcional: se puede guardar última dirección real del jugador para mejor predicción, aquí se predice 4 hacia la derecha con wrap
    let px = playerPosition.x + steps;
    let py = playerPosition.y;
    px = (px + cols) % cols;
    py = (py + rows) % rows;
    if(mazeMap[py][px] === 1) return {...playerPosition};
    return {x:px, y:py};
  }

  // Inky calcula el vector 2x blinky a posición dos adelante del jugador
  function inkyTarget(blinky, player) {
    // Posición dos arriba (por simplicidad) del jugador con wrap
    let px = (player.x + 0 + cols) % cols;
    let py = (player.y - 2 + rows) % rows;
    // Vector desde Blinky a ese punto
    let vx = px - blinky.x;
    let vy = py - blinky.y;
    // Doble vector
    let tx = (blinky.x + vx * 2 + cols) % cols;
    let ty = (blinky.y + vy * 2 + rows) % rows;
    if(mazeMap[ty][tx] === 1) {
      // Si muros en la posición objetivo, fallback a jugador
      return {...player};
    }
    return {x:tx, y:ty};
  }

  // Clyde persigue jugador si lejos, se aleja si cerca (distancia Manhattan >8)
  function clydeTarget(clyde, player){
    const dist = manhattanDist(clyde, player);
    if(dist > 8) return {...player};
    // Sino se posiciona en la esquina inferior izquierda del mapa
    return {x:0, y:rows-1};
  }

  function manhattanDist(pos1, pos2){
    const dx = Math.min(Math.abs(pos1.x - pos2.x), cols - Math.abs(pos1.x - pos2.x));
    const dy = Math.min(Math.abs(pos1.y - pos2.y), rows - Math.abs(pos1.y - pos2.y));
    return dx + dy;
  }

  // Elegir mejor movimiento hacia el target no chocando con muros
  function chooseGhostMove(ghost, target){
    // Posibles movimientos
    const moves = [
      {dx: 1, dy: 0},
      {dx:-1, dy: 0},
      {dx: 0, dy: 1},
      {dx: 0, dy:-1}
    ];
    // Filtramos movimientos legales (no murallas)
    const legalMoves = moves.filter(m => {
      const nx = (ghost.x + m.dx + cols) % cols;
      const ny = (ghost.y + m.dy + rows) % rows;
      return mazeMap[ny][nx] !== 1;
    });
    if(legalMoves.length === 0) return;
    // Calculamos cuál está más cerca del objetivo
    legalMoves.sort((a,b) => {
      const aX = (ghost.x + a.dx + cols) % cols;
      const aY = (ghost.y + a.dy + rows) % rows;
      const bX = (ghost.x + b.dx + cols) % cols;
      const bY = (ghost.y + b.dy + rows) % rows;
      const distA = manhattanDist({x:aX,y:aY}, target);
      const distB = manhattanDist({x:bX,y:bY}, target);
      return distA - distB;
    });
    // Moverse al primer movimiento óptimo escogido
    ghost.x = (ghost.x + legalMoves[0].dx + cols) % cols;
    ghost.y = (ghost.y + legalMoves[0].dy + rows) % rows;
  }

  // Chequear si un fantasma toca jugador
  function checkGhostCollision(){
    for(const g of ghosts){
      if(g.x === playerPosition.x && g.y === playerPosition.y){
        alert('¡Un fantasma te atrapó! Reiniciando...');
        resetGame();
        break;
      }
    }
  }

  // Chequear si jugador ganó (ha llegado a la meta con todas las pastillas recogidas)
  function checkGoal(){
    if (mazeMap[playerPosition.y][playerPosition.x] === 3){
      if(pillsCollected >= 7){
        alert(`¡Ganaste en ${moves} movimientos!`);
        resetGame();
      } else {
        alert(`Debes recolectar todas las 7 pastillas para poder ganar. Pastillas recogidas: ${pillsCollected}`);
      }
    }
  }

  // Reinicia juego y posiciona jugador en lugar distinto
  function resetGame(){
    moves = 0;
    pillsCollected = 0;
    movesCounter.textContent = moves;
    updatePillsCounter();
    // Vaciar pastillas y regenerar las 7
    pillsOnMap.clear();
    fillInitialPills();

    // Posicionar jugador en una posición aleatoria diferente
    do {
      const idx = Math.floor(Math.random() * playerStartPositions.length);
      var newPos = playerStartPositions[idx];
    } while(newPos.x === playerPosition.x && newPos.y === playerPosition.y);

    playerPosition = {...newPos};

    // Posicionar fantasmas en sus posiciones iniciales (predefinidas en scan)
    ghosts.forEach((g, i) => {
      g.x = ghostsInitPos[i].x;
      g.y = ghostsInitPos[i].y;
      g.dx = 0;
      g.dy = 0;
    });

    createMaze();
  }

  // Variables globales player initial positions and ghosts initial positions
  let ghostsInitPos = [];
  let playerStartPositions = [];

  // Para posicion inicial escanear el mapa y recoger datos
  function scanMapForPositions() {
    playerStartPositions =[];
    ghostsInitPos = [];
    for(let y=0; y<rows; y++){
      for(let x=0; x<cols; x++){
        if(mazeMap[y][x] === 2){
          playerStartPositions.push({x,y});
          mazeMap[y][x] = 0;
        }
        if(mazeMap[y][x] >= 5 && mazeMap[y][x] <= 8){
          ghostsInitPos[mazeMap[y][x]-5] = {x,y};
          mazeMap[y][x] = 0;
        }
      }
    }
  }

  // Inicializamos pastillas, seteando 7 en el mapa en espacios libres aleatorios
  const totalPills = 7;
  let pillsOnMap = new Set();

  function fillInitialPills(){
    pillsOnMap.clear();
    let count = 0;
    while(count<totalPills){
      const x = Math.floor(Math.random()*cols);
      const y = Math.floor(Math.random()*rows);
      if(mazeMap[y][x] === 0 && !(playerPosition.x === x && playerPosition.y === y) && !ghosts.some(g => g.x === x && g.y === y) && !pillsOnMap.has(`${x},${y}`)){
        pillsOnMap.add(`${x},${y}`);
        count++;
      }
    }
  }

  function updatePillsCounter(){
    pillsCounter.textContent = pillsCollected;
  }

  scanMapForPositions();
  fillInitialPills();

  function createMaze() {
    mazeElement.style.gridTemplateColumns = `repeat(${cols}, 30px)`;
    mazeElement.style.gridTemplateRows = `repeat(${rows}, 30px)`;
    mazeElement.innerHTML = '';

    for (let y=0; y<rows; y++) {
      for (let x=0; x<cols; x++) {
        const cellDiv = document.createElement('div');
        cellDiv.classList.add('cell');

        if(mazeMap[y][x] === 1){
          cellDiv.classList.add('wall');
        } else {
          cellDiv.classList.add('path');
          // Pastilla si está en set
          if(pillsOnMap.has(`${x},${y}`)){
            const pillEl = document.createElement('div');
            pillEl.classList.add('pill');
            cellDiv.appendChild(pillEl);
          }
        }
        cellDiv.id = `cell-${x}-${y}`;
        mazeElement.appendChild(cellDiv);
      }
    }
    drawPlayer();
    drawGhosts();
    updatePillsCounter();
  }

  function drawPlayer(){
    document.querySelectorAll('.player').forEach(el => el.classList.remove('player'));
    const cell = document.getElementById(`cell-${playerPosition.x}-${playerPosition.y}`);
    if(cell) cell.classList.add('player');
  }

  function drawGhosts(){
    document.querySelectorAll('.ghost').forEach(el => el.classList.remove('ghost', 'blinky', 'pinky', 'inky', 'clyde'));
    ghosts.forEach((g,i) => {
      const cell = document.getElementById(`cell-${g.x}-${g.y}`);
      if(cell){
        cell.classList.add('ghost', g.type);
      }
    });
  }

  window.addEventListener('keydown', e => {
    switch(e.key) {
      case 'ArrowUp': e.preventDefault(); movePlayer(0, -1); break;
      case 'ArrowDown': e.preventDefault(); movePlayer(0, 1); break;
      case 'ArrowLeft': e.preventDefault(); movePlayer(-1, 0); break;
      case 'ArrowRight': e.preventDefault(); movePlayer(1, 0); break;
    }
  });

  // Mover fantasmas con patrón definido cada 600ms
  setInterval(() => {
    ghosts.forEach(g => {
      // Obtener target según fantasma experto
      let target;
      switch(g.type){
        case 'blinky': 
          target = {...playerPosition};
          break;
        case 'pinky':
          target = predictPosition(playerPosition, 4);
          break;
        case 'inky':
          const blinky = ghosts.find(f => f.type === 'blinky');
          target = inkyTarget(blinky, playerPosition);
          break;
        case 'clyde':
          target = clydeTarget(g, playerPosition);
          break;
      }
      ghostMoveTowards(g, target);
    });
    drawGhosts();
    checkGhostCollision();
  }, 600);

  // Métodos para patrones de ghosts (como antes)

  // Predice posición delante del jugador con wrap (x,y, pasos)
  function predictPosition(player, steps) {
    const x = (player.x + steps + cols) % cols;
    const y = player.y;
    if(mazeMap[y][x] === 1) return {...player};
    return {x, y};
  }

  function inkyTarget(blinky, player){
    if(!blinky) return {...player};
    let px = (player.x + 0 + cols) % cols;
    let py = (player.y - 2 + rows) % rows;
    let vx = px - blinky.x;
    let vy = py - blinky.y;
    let tx = (blinky.x + vx * 2 + cols) % cols;
    let ty = (blinky.y + vy * 2 + rows) % rows;
    if(mazeMap[ty][tx] === 1) return {...player};
    return {x:tx, y:ty};
  }

  function clydeTarget(clyde, player){
    const dist = manhattanDist(clyde, player);
    if(dist > 8) return {...player};
    return {x:0, y:rows-1};
  }

  function manhattanDist(p1, p2){
    const dx = Math.min(Math.abs(p1.x - p2.x), cols - Math.abs(p1.x - p2.x));
    const dy = Math.min(Math.abs(p1.y - p2.y), rows - Math.abs(p1.y - p2.y));
    return dx + dy;
  }

  // Elige movimiento óptimo para ghost hacia target
  function ghostMoveTowards(ghost, target){
    const moves = [
      {dx: 1, dy: 0},
      {dx:-1, dy: 0},
      {dx: 0, dy: 1},
      {dx: 0, dy:-1}
    ];
    const legalMoves = moves.filter(m => {
      const nx = (ghost.x + m.dx + cols) % cols;
      const ny = (ghost.y + m.dy + rows) % rows;
      return mazeMap[ny][nx] !==1;
    });
    if(legalMoves.length===0) return;
    legalMoves.sort((a,b)=>{
      const ax = (ghost.x + a.dx + cols) % cols;
      const ay = (ghost.y + a.dy + rows) % rows;
      const bx = (ghost.x + b.dx + cols) % cols;
      const by = (ghost.y + b.dy + rows) % rows;
      return manhattanDist({x:ax,y:ay},target) - manhattanDist({x:bx,y:by},target);
    });
    ghost.x = (ghost.x + legalMoves[0].dx + cols) % cols;
    ghost.y = (ghost.y + legalMoves[0].dy + rows) % rows;
  }

  function checkGhostCollision(){
    for(let g of ghosts){
      if(g.x === playerPosition.x && g.y === playerPosition.y){
        alert('¡Fantasma atrapó! Jugador reiniciado.');
        resetPlayerPosition();
        break;
      }
    }
  }

  // Cuando el jugador muere, se reposiciona en un espacio abierto aleatorio diferente
  function resetPlayerPosition(){
    let openSpaces = [];
    for(let y=0; y<rows; y++){
      for(let x=0; x<cols; x++){
        if(mazeMap[y][x] === 0 && !ghosts.some(g => g.x===x && g.y===y)){
          openSpaces.push({x,y});
        }
      }
    }
    // Evitar la posición actual para evitar muerte instantánea
    openSpaces = openSpaces.filter(pos => !(pos.x === playerPosition.x && pos.y === playerPosition.y));
    if(openSpaces.length){
      const pos = openSpaces[Math.floor(Math.random()*openSpaces.length)];
      playerPosition = pos;
      drawPlayer();
    }
  }

  // Inicializamos juego con todo
  resetGame();

</script>

</body>
</html>
